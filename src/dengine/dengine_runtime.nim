import dengine_types
import dengine_memory
import dengine_stack
import dengine_utils
import tables

type
  DEngineRuntime* = ref object
    ## This is the VM itself, the runtime executes bytecode generated by the compiler
    ##
    ## Note: The VM stack is implemented as a region in memory, starting from the end.
    memory: DEngineMemory
    stack: DEngineStack ## Operates directly on memory
    programSize: int ## Holds the length of the currently loaded program
    ip: int32 ## Instruction pointer (starts at the beginning of memory)

proc init*(self: DEngineRuntime) =
  ## Initialize DEngineRuntime

  # Set up memory, fixed at 512 bytes large for now
  self.memory = DEngineMemory()
  self.memory.init(512)

  self.stack = DEngineStack()
  self.stack.init(self.memory)

# TODO: test
proc load*(self: DEngineRuntime, program: seq[uint8]) =
  ## Load a program (DEN bytecode) into memory
  self.memory.put(0, program)
  self.programSize = program.len
  self.ip = 0 # Start the instruction pointer at the beginning of memory

# TODO: test
proc op_addi(runtime: DEngineRuntime) =
  let result = (
    runtime.stack.popDword.toInt32 +
    runtime.stack.popDword.toInt32)
    .toBytes
  runtime.stack.push([result[3], result[2], result[1], result[0]])

# TODO: test
proc op_addf(runtime: DEngineRuntime) =
  let result = (
    runtime.stack.popDword.toFloat32 +
    runtime.stack.popDword.toFloat32)
    .toBytes
  runtime.stack.push([result[3], result[2], result[1], result[0]])

# TODO: test
proc op_psh(runtime: DEngineRuntime) =
  runtime.stack.push([
    runtime.memory.get(runtime.ip + 4),
    runtime.memory.get(runtime.ip + 3),
    runtime.memory.get(runtime.ip + 2),
    runtime.memory.get(runtime.ip + 1)])
  runtime.ip += 4

proc op_out(runtime: DEngineRuntime) =
  let poppedDword: array[4, uint8] = runtime.stack.popDword
  {.noSideEffect.}:
    echo "f32: " & $poppedDword.toFloat32 & "\t\tint32: " &
      $poppedDword.toInt32

proc execute(self: Opcode, runtime: DEngineRuntime) =
  ## Maps opcodes to procedures that handle them and executes it
  {
    Opcode.ADDI: op_addi,
    Opcode.ADDF: op_addf,
    Opcode.PSH: op_psh,
    Opcode.OUT: op_out
  }.toTable[self](runtime)

# TODO: test
proc tick*(self: DEngineRuntime) =
  ## Grab the current instruction, interpret it as an opcode and execute it
  ((Opcode)self.memory.get(self.ip)).execute(self)
  self.ip += 1

# TODO: test
proc run*(self: DEngineRuntime) =
  ## Run all code at once
  while self.ip < self.programSize:
    self.tick()
