import dengine_types
import dengine_memory
import dengine_stack
import dengine_runtime_ops
import tables

type
  DEngineRuntime* = ref object
    ## This is the VM itself, the runtime executes bytecode generated by the compiler
    ##
    ## Note: The VM stack is implemented as a region in memory, starting from the end.
    memory*: DEngineMemory
    stack*: DEngineStack ## Operates directly on memory
    programSize: int ## Holds the length of the currently loaded program
    ip*: int32 ## Instruction pointer (starts at the beginning of memory)

proc init*(self: DEngineRuntime) =
  ## Initialize DEngineRuntime

  # Set up memory, fixed at 512 bytes large for now
  self.memory = DEngineMemory()
  self.memory.init(512)

  self.stack = DEngineStack()
  self.stack.init(self.memory)

# TODO: test
proc load*(self: DEngineRuntime, program: seq[uint8]) =
  ## Load a program (DEN bytecode) into memory
  self.memory.put(0, program)
  self.programSize = program.len
  self.ip = 0 # Start the instruction pointer at the beginning of memory

proc execute(self: Opcode, runtime: DEngineRuntime) =
  ## Maps opcodes to procedures that handle them and executes it
  {
    Opcode.ADDI: op_add_int32,
    Opcode.ADDF: op_add_float32,
    Opcode.PSH: op_push,
    Opcode.OUT: op_out
  }.toTable[self](runtime.ip, runtime.memory, runtime.stack)

# TODO: test
proc tick*(self: DEngineRuntime) =
  ## Grab the current instruction, interpret it as an opcode and execute it
  ((Opcode)self.memory.get(self.ip)).execute(self)
  self.ip += 1

# TODO: test
proc run*(self: DEngineRuntime) =
  ## Run all code at once
  while self.ip < self.programSize:
    self.tick()
